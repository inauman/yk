Here‚Äôs a playbook you can drop into **`.cursor/rules/python_best_practices.mdc`** (or whatever rule-set you use) that turns the ‚Äúflail until it compiles‚Äù loop into something that feels a lot more like what a seasoned developer does when they touch an unfamiliar library.

> **TL;DR**  
>  Add explicit *introspection* and *sanity-check* steps to every task. The rule engine will force Cursor to run them first, cache the facts it learns, and only *then* start writing production code or tests.

---

## 1‚ÄÇMacro-rule: ‚ÄúIntrospect before you code‚Äù

```md
### python_best_practices.mdc

RULE: For every new third-party import in a patch,
      1. Confirm the installed distribution name and version with `importlib.metadata.version`.
      2. Run `inspect.getmembers(<module>)` and `inspect.signature` on any function you intend to call.
      3. Cache the findings in a comment block at the top of the edited file (or test file) so future diffs can re-use them.
      4. If the public API is ambiguous, create and run a 5-line throw-away REPL snippet (inside a `# /// scratch` code fence) that calls the function with dummy data and prints the return type.
EXCEPTION: Skip if that exact import path has already been introspected in this repository (look for an existing comment block that records the version + callable signatures).
```

**Why it helps**  
Cursor stops guessing argument names: it *must* call `inspect.signature` first. The cached comment block acts like auto-generated internal docs, so the *next* edit doesn‚Äôt redo the work.

---

## 2‚ÄÇMicro-rules you can chain to the macro

| Concern | Rule snippet |
|---------|--------------|
| **Version drift** | `Always pin every new dependency with the exact major.minor version found via importlib.metadata.version().` |
| **Enum / constant lookup** | `When a kwarg expects an enum value, call dir(<EnumClass>) and paste the resulting list into the scratch comment so it‚Äôs obvious which members exist.` |
| **Return-type clarity** | `For non-primitive return values, run type() on the result in the scratch snippet and record the class path.` |
| **Minimal working example** | `If a function mutates external state (DB, file-system, network), wrap the scratch snippet in a pytest @pytest.mark.skip block so it never runs in CI but is kept as living documentation.` |
| **Doc discovery** | `If inspect.getdoc() returns None, use importlib.resources.read_text(pkg, "py.typed", package=...) OR grep the site-packages dir for "def <funcname>(" and link the relative path in a comment.` |

Stick any of these under the main ‚ÄúIntrospect before you code‚Äù rule; Cursor will treat them as sub-steps.

---

## 3‚ÄÇTemplate comment block Cursor should emit

Cursor can be told to prepend something like this to each file it touches:

```py
# ---
# üìé  Library quick-ref (autogenerated, do not edit)
#   package      : webauthn  == 2.1.0
#   key callables:
#       generate_registration_options(rp_id: str, rp_name: str, ... ) -> RegistrationOptions
#       verify_registration_response(credential, expected_challenge: bytes, ...) -> Verification
#   enum hints   : AuthenticatorSelectionCriteria, UserVerificationRequirement
#   scratch run  : see below for a 5-line sanity check
# ---
# /// scratch
# import json, inspect, importlib.metadata, webauthn as w
# print(importlib.metadata.version("webauthn"))
# print(inspect.signature(w.generate_registration_options))
# opts = w.generate_registration_options(rp_id="example.com", rp_name="Demo", user_name="u") 
# print(type(opts))
# /// end scratch
```

Tell Cursor to *reuse* this block instead of re-emitting it on every change; that stops noise in diffs.

---

## 4‚ÄÇA helper utility you can vendor once

Drop a tiny helper into your repo‚Äî`tools/introspect.py`:

```py
def snapshot(module_name: str, *callables: str) -> str:
    """Return a markdown block with version and signatures."""
    import importlib, importlib.metadata, inspect, textwrap
    mod = importlib.import_module(module_name)
    parts = [
        f"- **package**: `{module_name}` == {importlib.metadata.version(module_name)}"
    ]
    for name in callables:
        sig = inspect.signature(getattr(mod, name))
        parts.append(f"- `{name}{sig}`")
    return textwrap.indent("\n".join(parts), "  ")
```

Then your rule can say: *‚ÄúIf no comment block exists, call `tools.introspect.snapshot` and paste its output.‚Äù* Cursor executes it, pastes the markdown, and moves on.

---

## 5‚ÄÇDon‚Äôt forget a **‚Äúfail fast‚Äù test rule**

```md
RULE: After introducing a new third-party call, create a pytest that:
      1. Imports the callable.
      2. Asserts it runs with *minimal* happy-path data.
      3. Marks the test as xfail if the library major version differs.
Purpose: CI breaks immediately when the dependency updates and the signature changes.
```

---

### Putting it all together

1. **Cursor pulls in a lib** ‚Üí sees the rule ‚Üí introspects ‚Üí writes scratch snippet + signature cache.  
2. **Cursor codes the feature** using the cached signature‚Äîno blind kwargs.  
3. **A tiny smoke test** guarantees the callable still exists next time `pip` bumps.

Result: far fewer ‚Äúoops wrong kwarg name‚Äù iterations, and you accumulate a living set of *private docs* for every dependency‚Äîexactly how a senior engineer keeps surprises to a minimum. üöÄ

Feel free to cherry-pick or tweak the rule snippets‚ÄîCursor‚Äôs rule engine is just Markdown + pattern matching, so you can refine the wording any time you notice a new type of foot-gun. Happy hacking! üòä